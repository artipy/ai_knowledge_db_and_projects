# Роли в чатах и многоэтапные диалоги

Эта заметка описывает систему ролей в чат-взаимодействиях с LLM, использование системных сообщений для управления поведением модели и создание многоэтапных диалогов (multi-turn conversations) с сохранением контекста.

## Связанные заметки

- [[OpenAI_API/Introduction_to_OpenAI_API|Введение в OpenAI API]] - базовая информация о подключению API
- [[OpenAI_API/Working_with_OpenAI_API_in_Python|Работа с OpenAI API в Python]] - практические примеры работы с API и shot prompting
- [[Prompt_Engineering/Prompt_Engineering_Best_Practices|Лучшие практики Prompt Engineering]] - ключевые принципы создания эффективных промптов, структурирование запросов
- [[Prompt_Engineering/Advanced_Prompt_Engineering_Strategies|Продвинутые стратегии Prompt Engineering]] - Few-Shot через user-assistant диалоги, Chain-of-Thought и другие продвинутые техники
- [[Prompt_Engineering/Prompt_Engineering_for_Business_Applications|Prompt Engineering для бизнес-приложений]] - практическое применение ролей и диалогов для бизнес-задач
- [[Exercises/02_Chat_Roles_and_Conversations_Exercise|Практическое задание №2]] - задания для отработки навыков работы с ролями и диалогами

## Подготовка к работе

```python
from openai import OpenAI
from dotenv import load_dotenv
import os

load_dotenv()

client = OpenAI(
    api_key=os.getenv('GEMINI_TOKEN'),
    base_url=os.getenv('BASE_URL')
)
```

## Три роли в чат-системах

В системе chat completions используются три роли для организации диалога:

### 1. System (Системная роль)

**Назначение**: Управление поведением ассистента, установка ограничений и определение структуры результата.

**Характеристики**:
- Задает "личность" модели (преподаватель, консультант, эксперт и т.д.)
- Определяет стиль общения (краткий, развернутый, формальный и т.д.)
- Устанавливает границы допустимого поведения
- Указывает желаемый формат ответов

### 2. User (Роль пользователя)

**Назначение**: Отправка запросов и вопросов к модели.

**Характеристики**:
- Содержит непосредственные вопросы пользователя
- Может включать примеры для few-shot prompting (первая часть примера)
- Передает контекст для обработки

### 3. Assistant (Роль ассистента)

**Назначение**: Представление ответов модели.

**Характеристики**:
- Используется для синтетического создания истории диалога
- Применяется для демонстрации желаемого стиля ответа
- Помогает в few-shot prompting (вторая часть примера - ответ модели)

## Использование системной роли

### Базовый пример: Установка контекста

```python
response = client.chat.completions.create(
    model = os.getenv('BASE_MODEL'),
    messages = [
        {
            'role':'system',
            'content':'Ты преподаватель языка программирования Python, который говорит кратко и сдержано'
        },
        {
            'role':'user',
            'content':'Какая разница между изменяемыми и неизменяемыми объектами?'
        }
    ]
)

print(response.choices[0].message.content)
```

**Результат**: Модель отвечает кратко и сдержано, в соответствии с заданным стилем.

### Критически важное использование: Установка границ

Системная роль помогает предотвратить использование модели не по назначению. Это особенно важно для чат-ботов с узкой специализацией.

#### Пример: Ограничение области ответственности

```python
sys_msg = '''
Ты ассистент для подготовки к экзамену по предмету "Финансы". Если тебя спросят про специфические, реально существующие в мире финансовые вложения или предложения покупок, сопряженных с риском потери средств, отвечай следующим образом:

Прошу прощения, но я не даю финансовых консультаций.
'''

response = client.chat.completions.create(
    model = os.getenv('BASE_MODEL'),
    messages = [
        {
            'role':'system',
            'content':sys_msg
        },
        {
            'role':'user',
            'content':'Какие акции купить в 2026 году?'
        }
    ]
)

print(response.choices[0].message.content)
```

**Результат**:
```
Прошу прощения, но я не даю финансовых консультаций.
```

**Важность**: Это защищает как пользователей от потенциально вредных советов, так и создателей системы от юридической ответственности.

## Использование роли Assistant для Few-Shot Prompting

Роль assistant можно использовать для создания синтетических примеров диалога, что помогает модели понять желаемый стиль и формат ответов.

### Пример: Контроль стиля ответа

```python
response = client.chat.completions.create(
    model = os.getenv('BASE_MODEL'),
    messages = [
        {
            'role':'system',
            'content':'Ты преподаватель языка программирования Python, который говорит кратко и сдержано'
        },
        {
            'role':'user',
            'content':'Что такое list в Python?'
        },
        {
            'role':'assistant',
            'content':'List (список) в Python это последовательность значений, обрамленных в квадратные скобки []'
        },
        {
            'role':'user',
            'content':'Какая разница между изменяемыми и неизменяемыми объектами?'
        }
    ]
)

print(response.choices[0].message.content)
```

**Результат**: Модель следует установленному в примере формату - краткому и структурированному ответу.

## Когда использовать примеры в разных ролях

### System prompt - для структуры и ограничений
Используйте примеры в системном сообщении когда необходимо:
- Определить желаемую структуру результата
- Установить ограничения на поведение модели
- Задать формат вывода (JSON, таблица, список и т.д.)

### User-Assistant диалог - для стиля и тона
Используйте синтетические диалоги когда необходимо:
- Продемонстрировать желаемый тон общения
- Показать манеру изложения
- Задать уровень детализации ответов

### User prompt - для контекста задачи
Используйте примеры в user сообщении когда необходимо:
- Дать модели больше контекста для решения новой задачи
- Показать конкретные примеры входных данных
- Применить классический few-shot prompting

Более подробно о технике shot prompting можно узнать в [[OpenAI_API/Working_with_OpenAI_API_in_Python|заметке о работе с API]].

## Multi-Turn Conversations (Многоэтапные диалоги)

До этого момента мы создавали простые single-turn взаимодействия - один запрос, один ответ. Однако большинство чат-приложений (ChatGPT, Claude и др.) поддерживают контекст разговора, позволяя моделям "помнить" предыдущие сообщения.

### Как это работает

Для сохранения контекста необходимо:
1. Создать список `messages` с начальными сообщениями (обычно system)
2. При каждом новом вопросе добавлять его в список под ролью `user`
3. Получать ответ от модели
4. Добавлять ответ модели в список под ролью `assistant`
5. Передавать весь накопленный список при следующем запросе

### Практический пример

```python
# Инициализация истории с системным сообщением
messages = [
    {
        'role':'system',
        'content':'Ты преподаватель науки о данных, который отвечает короткими и простыми объяснениями'
    }
]

# Список вопросов для демонстрации
user_qs = [
    'Почему Python такой популярный?',
    'Резюмируй это в одно предложение'
]

# Цикл для обработки каждого вопроса
for q in user_qs:
    # Отображаем вопрос пользователя
    print(f'User: {q}')

    # Формируем словарь с сообщением пользователя
    user_dic = {
        'role':'user',
        'content':q
    }

    # Добавляем вопрос в историю
    messages.append(user_dic)

    # Отправляем всю историю модели
    response = client.chat.completions.create(
        model = os.getenv('BASE_MODEL'),
        messages = messages
    )

    # Получаем ответ модели
    assistant_dic = {
        'role':'assistant',
        'content': response.choices[0].message.content
    }

    # Добавляем ответ в историю
    messages.append(assistant_dic)

    # Выводим ответ
    print(f'Assistant: {assistant_dic["content"]}\n')
```

**Вывод**:
```
User: Почему Python такой популярный?
Assistant: Python популярен благодаря четырем главным причинам:

1. **Простота:** Его синтаксис похож на обычный английский язык
2. **Огромная экосистема:** Готовые библиотеки для любых задач
3. **Сообщество:** Активная поддержка и множество решений
4. **Универсальность:** От скриптов до нейросетей

User: Резюмируй это в одно предложение
Assistant: Python популярен благодаря своей простоте, универсальности и огромному количеству готовых библиотек для решения любых задач.
```

### Ключевые моменты

**Важно**: Модель "помнит" контекст только потому, что мы передаем всю историю при каждом запросе. Сама по себе модель не сохраняет состояние между вызовами API.

**Структура списка messages**:
```python
[
    {"role": "system", "content": "Системное сообщение"},
    {"role": "user", "content": "Первый вопрос"},
    {"role": "assistant", "content": "Первый ответ"},
    {"role": "user", "content": "Второй вопрос"},
    {"role": "assistant", "content": "Второй ответ"},
    # ... и так далее
]
```

## Стоимость и оптимизация

### Учет роста контекста

При использовании multi-turn conversations важно помнить:

- **Каждый запрос включает ВСЮ историю**: С каждым новым сообщением количество входных токенов растет
- **Стоимость увеличивается линейно**: 10-е сообщение будет дороже 1-го в несколько раз
- **Ограничение контекста модели**: У каждой модели есть максимальная длина контекста (например, 128K токенов)

### Стратегии оптимизации

1. **Ограничение истории**: Сохранять только N последних сообщений
2. **Резюмирование**: Периодически резюмировать старую часть диалога
3. **Удаление системных сообщений**: Использовать system только в начале
4. **Выборочное сохранение**: Хранить только критически важные сообщения

## Рекомендации по использованию

### System роль
- Используйте для определения "личности" ассистента
- Обязательно устанавливайте границы допустимого поведения
- Определяйте желаемый формат вывода
- Не дублируйте system сообщение в каждом запросе

### User роль
- Формулируйте четкие и конкретные вопросы
- Используйте для предоставления контекста
- Можете включать примеры прямо в текст запроса

### Assistant роль
- Используйте для few-shot prompting
- Создавайте синтетические примеры диалога
- Демонстрируйте желаемый стиль ответов
- Не используйте для single-turn задач без необходимости

### Multi-turn диалоги
- Всегда отслеживайте размер контекста
- Планируйте стратегию управления историей для длинных диалогов
- Помните о линейном росте стоимости
- Тестируйте поведение модели с разной длиной истории

## Типичные сценарии использования

### Образовательный чат-бот
```python
messages = [
    {
        'role': 'system',
        'content': 'Ты терпеливый преподаватель математики. Объясняй концепции просто, используй примеры из повседневной жизни.'
    }
]
```

### Техническая поддержка
```python
messages = [
    {
        'role': 'system',
        'content': '''Ты ассистент технической поддержки.
        - Задавай уточняющие вопросы перед решением проблемы
        - Предлагай пошаговые инструкции
        - Если проблема критическая, рекомендуй обратиться к специалисту'''
    }
]
```

### Творческий ассистент
```python
messages = [
    {
        'role': 'system',
        'content': 'Ты креативный писатель. Используй образный язык, метафоры и яркие описания.'
    }
]
```

## Практика

Для закрепления материала рекомендуется выполнить [[Exercises/02_Chat_Roles_and_Conversations_Exercise|Практическое задание №2]], которое охватывает:
- Управление поведением модели через системную роль
- Установку границ и ограничений для специализированных чат-ботов
- Few-shot prompting через синтетические диалоги
- Создание multi-turn conversations с анализом стоимости
- Оптимизацию длинных диалогов

---

*Эта заметка создана на основе практических примеров работы с системой ролей и multi-turn диалогами в OpenAI API.*
