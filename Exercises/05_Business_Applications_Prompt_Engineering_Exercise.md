# Практическое задание №5: Prompt Engineering для бизнес-приложений

## Цель задания

Отработать на практике применение техник промпт-инжиниринга для решения реальных бизнес-задач: резюмирование и расширение текста, трансформация текста, анализ текста, а также генерация и объяснение кода.

## Связанные материалы

- [[Prompt_Engineering/Prompt_Engineering_for_Business_Applications|Prompt Engineering для бизнес-приложений]]
- [[Prompt_Engineering/Prompt_Engineering_Best_Practices|Лучшие практики Prompt Engineering]]
- [[Prompt_Engineering/Advanced_Prompt_Engineering_Strategies|Продвинутые стратегии Prompt Engineering]]
- [[OpenAI_API/Working_with_OpenAI_API_in_Python|Работа с OpenAI API в Python]]

## Предварительные требования

- Установленная библиотека `openai` и `python-dotenv`
- Настроенный `.env` файл с API ключом
- Базовое понимание Python
- Выполненные задания [[Exercises/01_OpenAI_API_Text_Processing_Exercise|№1]], [[Exercises/03_Prompt_Engineering_Best_Practices_Exercise|№3]] и [[Exercises/04_Advanced_Prompt_Engineering_Strategies_Exercise|№4]]

---

## Базовая настройка

Используйте следующую конфигурацию для всех заданий:

```python
from openai import OpenAI
from dotenv import load_dotenv
import os

load_dotenv()

client = OpenAI(
    api_key=os.getenv("GEMINI_TOKEN"),
    base_url=os.getenv("BASE_URL")
)

def get_response(prompt: str, temperature: float = 1.0) -> str:
    """Базовая функция для получения ответа от модели"""
    response = client.chat.completions.create(
        model=os.getenv("BASE_MODEL"),
        messages=[{'role': 'user', 'content': prompt}],
        temperature=temperature
    )
    return response.choices[0].message.content
```

---

## Часть 1: Резюмирование и расширение текста (25 минут)

### Задача 1.1: Анализ и резюмирование отзывов клиентов

**Исходные данные:**

```python
product_reviews = """
Отзыв 1 (Иван П., 15.02.2024):
Купил новый смартфон TechPhone X5 две недели назад. Камера действительно впечатляет -
фотографии получаются четкими даже при слабом освещении. Батарея держит весь день при
активном использовании. Однако экран слишком яркий даже на минимальных настройках, что
напрягает глаза. Также разочаровала медленная зарядка - полная зарядка занимает почти
3 часа. За эту цену ожидал большего.

Отзыв 2 (Мария С., 18.02.2024):
Отличный телефон! Быстрый, стильный, экран яркий и четкий. Особенно радует, что он
поддерживает все современные приложения без зависаний. Немного тяжеловат, но это не
критично. Рекомендую всем, кто ищет надежный смартфон в среднем ценовом сегменте.

Отзыв 3 (Алексей Н., 20.02.2024):
После месяца использования могу сказать, что телефон хороший, но не без недостатков.
Производительность на высоте, камера отличная, звук чистый. Но есть проблема с перегревом
при играх - телефон становится горячим через 20-30 минут. Служба поддержки сказала, что
это нормально, но меня это беспокоит.

Отзыв 4 (Елена К., 22.02.2024):
Ужасный опыт покупки! Заказала телефон онлайн, доставка задержалась на неделю без
объяснений. Когда наконец получила, обнаружила царапину на задней панели. Связалась с
поддержкой - долго не отвечали, потом предложили скидку 5% на следующую покупку вместо
замены. Сам телефон работает нормально, но сервис просто отвратительный.
"""
```

**Что нужно сделать:**

1. **Базовое резюмирование**: Создайте краткое резюме (2-3 предложения) всех отзывов
2. **Фокусное резюмирование**: Извлеките только технические характеристики продукта в формате маркированного списка
3. **Структурированное резюмирование**: Создайте резюме в следующем формате:
   - Позитивные аспекты (что хвалят)
   - Негативные аспекты (что критикуют)
   - Проблемы с сервисом
   - Общая рекомендация для производителя

**Ожидаемый результат:**

```
=== БАЗОВОЕ РЕЗЮМЕ ===
[2-3 предложения]

=== ТЕХНИЧЕСКИЕ ХАРАКТЕРИСТИКИ ===
- [характеристика 1]
- [характеристика 2]
...

=== СТРУКТУРИРОВАННЫЙ АНАЛИЗ ===
Позитивные аспекты:
- [аспект 1]
- [аспект 2]

Негативные аспекты:
- [аспект 1]
- [аспект 2]

Проблемы с сервисом:
- [проблема 1]

Рекомендация для производителя:
[2-3 конкретных действия]
```

**Шаблон кода:**

```python
# Задача 1: Базовое резюмирование
prompt_basic = f"""Резюмируй следующие отзывы о продукте в 2-3 предложениях:

{product_reviews}"""

print("=== БАЗОВОЕ РЕЗЮМЕ ===")
print(get_response(prompt_basic, temperature=0.3))

# Задача 2: Фокусное резюмирование
prompt_focused = f"""Извлеки из следующих отзывов только упоминания технических
характеристик продукта (камера, батарея, экран, производительность и т.д.)
в формате маркированного списка:

{product_reviews}"""

print("\n=== ТЕХНИЧЕСКИЕ ХАРАКТЕРИСТИКИ ===")
print(get_response(prompt_focused, temperature=0.3))

# Задача 3: Структурированное резюмирование
prompt_structured = """# Ваш код здесь
# Создайте промпт для структурированного анализа
"""

print("\n=== СТРУКТУРИРОВАННЫЙ АНАЛИЗ ===")
# Ваш код здесь
```

---

### Задача 1.2: Расширение текста для маркетинговой рассылки

**Исходные данные:**

```python
key_features = """
Продукт: Система умного дома SmartHome Pro
- Управление освещением, климатом и безопасностью
- Голосовое управление (Alexa, Google Assistant, Яндекс.Алиса)
- Мобильное приложение с удаленным доступом
- Интеграция с 200+ устройствами разных производителей
- Сценарии автоматизации (утро, вечер, отпуск, гости)
- Энергомониторинг и оптимизация потребления
- Цена: 29,990 руб (базовый комплект)
"""
```

**Что нужно сделать:**

1. Создайте **три версии** маркетингового текста для разных аудиторий:
   - **Версия 1**: Технически подкованные пользователи (150-200 слов, профессиональный тон)
   - **Версия 2**: Семейная аудитория (120-150 слов, дружелюбный тон)
   - **Версия 3**: Бизнес-сегмент (100-120 слов, формальный тон)

2. Каждая версия должна включать:
   - Привлекающий внимание заголовок
   - Основное описание с акцентом на потребности аудитории
   - Призыв к действию (CTA)

**Ожидаемый результат:**

```
=== ВЕРСИЯ ДЛЯ ТЕХНИЧЕСКИ ПОДКОВАННЫХ ===
Заголовок: [заголовок]

[Текст 150-200 слов]

=== ВЕРСИЯ ДЛЯ СЕМЕЙ ===
Заголовок: [заголовок]

[Текст 120-150 слов]

=== ВЕРСИЯ ДЛЯ БИЗНЕСА ===
Заголовок: [заголовок]

[Текст 100-120 слов]
```

**Шаблон кода:**

```python
audiences = [
    {
        "name": "технически подкованных",
        "tone": "профессиональный",
        "length": "150-200 слов",
        "focus": "технические возможности и интеграции"
    },
    {
        "name": "семей",
        "tone": "дружелюбный и теплый",
        "length": "120-150 слов",
        "focus": "удобство, безопасность и комфорт семьи"
    },
    {
        "name": "бизнеса",
        "tone": "формальный деловой",
        "length": "100-120 слов",
        "focus": "эффективность, экономия и безопасность"
    }
]

for audience in audiences:
    prompt = f"""Создай маркетинговый текст для продукта на основе следующих характеристик:

{key_features}

Требования:
- Целевая аудитория: {audience['name']}
- Тон: {audience['tone']}
- Длина: {audience['length']}
- Фокус: {audience['focus']}
- Включи привлекающий внимание заголовок
- Заверши призывом к действию

Формат:
Заголовок: [заголовок]

[Основной текст]"""

    print(f"\n=== ВЕРСИЯ ДЛЯ {audience['name'].upper()} ===")
    print(get_response(prompt, temperature=0.7))
```

---

## Часть 2: Трансформация текста (20 минут)

### Задача 2.1: Многоэтапная трансформация делового письма

**Исходные данные:**

```python
informal_message = """
Привет команда!!!
слушайте вчера обсуждали с Петровым из отдела продаж насчет нового проекта
типа надо бы запустить маркетинговую кампанию для нового продукта уже к концу месяца
бюджет у нас около 500к
кто будет заниматься дизайном баннеров и лендинга??
и еще нужно подумать про таргетинг в соцсетях
давайте встретимся в четверг обсудим детали
"""
```

**Что нужно сделать:**

Выполните **последовательную трансформацию** текста в 4 этапа:

1. **Этап 1**: Исправьте грамматику и пунктуацию
2. **Этап 2**: Преобразуйте в формальный деловой стиль
3. **Этап 3**: Структурируйте в формате email (с темой, приветствием, основной частью, призывом к действию и подписью)
4. **Этап 4**: Добавьте конкретность (точные сроки, зоны ответственности, следующие шаги)

**Ожидаемый результат:**

```
=== ЭТАП 1: ГРАММАТИКА И ПУНКТУАЦИЯ ===
[Исправленный текст]

=== ЭТАП 2: ФОРМАЛЬНЫЙ СТИЛЬ ===
[Текст в деловом стиле]

=== ЭТАП 3: СТРУКТУРА EMAIL ===
Тема: [тема письма]

[Приветствие]

[Основная часть]

[Призыв к действию]

[Подпись]

=== ЭТАП 4: ДОБАВЛЕНИЕ КОНКРЕТНОСТИ ===
[Финальная версия с конкретными деталями]
```

**Шаблон кода:**

```python
# Этап 1: Исправление грамматики
prompt_step1 = f"""Исправь все грамматические и пунктуационные ошибки в следующем тексте:

{informal_message}"""

result_step1 = get_response(prompt_step1, temperature=0.0)
print("=== ЭТАП 1: ГРАММАТИКА И ПУНКТУАЦИЯ ===")
print(result_step1)

# Этап 2: Формальный стиль
prompt_step2 = f"""Преобразуй следующий текст в формальный деловой стиль:

{result_step1}"""

result_step2 = get_response(prompt_step2, temperature=0.0)
print("\n=== ЭТАП 2: ФОРМАЛЬНЫЙ СТИЛЬ ===")
print(result_step2)

# Этап 3: Структура email
prompt_step3 = """# Ваш код здесь
# Создайте промпт для структурирования в формате email
"""

# result_step3 = # Ваш код здесь
# print("\n=== ЭТАП 3: СТРУКТУРА EMAIL ===")
# print(result_step3)

# Этап 4: Добавление конкретности
prompt_step4 = """# Ваш код здесь
# Создайте промпт для добавления конкретных деталей
"""

# result_step4 = # Ваш код здесь
# print("\n=== ЭТАП 4: ДОБАВЛЕНИЕ КОНКРЕТНОСТИ ===")
# print(result_step4)
```

---

### Задача 2.2: Адаптация технического текста для разных аудиторий

**Исходные данные:**

```python
technical_text = """
Наша платформа использует RESTful API архитектуру для взаимодействия с клиентскими
приложениями. Аутентификация реализована через OAuth 2.0 протокол с использованием
JWT токенов. Данные передаются в JSON формате через HTTPS соединение. Система
поддерживает горизонтальное масштабирование через Kubernetes оркестрацию контейнеров
Docker. Для обеспечения высокой доступности используется архитектура микросервисов с
репликацией базы данных PostgreSQL и кэшированием через Redis.
"""
```

**Что нужно сделать:**

Адаптируйте технический текст для **трех разных аудиторий**:

1. **Для топ-менеджмента** (нетехническая аудитория):
   - Простой язык без технических терминов
   - Фокус на бизнес-ценности
   - 2-3 предложения

2. **Для клиентов** (базовое понимание технологий):
   - Понятный язык с минимумом технических терминов
   - Фокус на преимуществах для пользователя
   - 3-4 предложения

3. **Для технической документации** (техническая аудитория):
   - Сохранить технические термины
   - Добавить больше деталей
   - Структурировать по компонентам
   - 4-5 предложений

**Ожидаемый результат:**

```
=== ДЛЯ ТОП-МЕНЕДЖМЕНТА ===
[Текст 2-3 предложения]

=== ДЛЯ КЛИЕНТОВ ===
[Текст 3-4 предложения]

=== ДЛЯ ТЕХНИЧЕСКОЙ ДОКУМЕНТАЦИИ ===
[Структурированный текст 4-5 предложений]
```

**Шаблон кода:**

```python
adaptations = [
    {
        "audience": "топ-менеджмента (нетехническая аудитория)",
        "style": "простой язык без технических терминов",
        "focus": "бизнес-ценность и преимущества",
        "length": "2-3 предложения"
    },
    {
        "audience": "клиентов (базовое понимание технологий)",
        "style": "понятный язык с минимумом технических терминов",
        "focus": "преимущества для конечного пользователя",
        "length": "3-4 предложения"
    },
    {
        "audience": "разработчиков (технической документации)",
        "style": "технический язык с сохранением терминов",
        "focus": "архитектурные компоненты и их взаимодействие",
        "length": "4-5 предложений, структурировано по компонентам"
    }
]

for adaptation in adaptations:
    prompt = f"""Адаптируй следующий технический текст для {adaptation['audience']}:

{technical_text}

Требования:
- Стиль: {adaptation['style']}
- Фокус: {adaptation['focus']}
- Длина: {adaptation['length']}"""

    print(f"\n=== ДЛЯ {adaptation['audience'].split('(')[0].strip().upper()} ===")
    print(get_response(prompt, temperature=0.3))
```

---

## Часть 3: Анализ текста (25 минут)

### Задача 3.1: Многоклассовая классификация тикетов в службу поддержки

**Исходные данные:**

```python
support_tickets = [
    """Тикет #1001
    От: client1@email.com
    Дата: 25.02.2024

    Не могу войти в личный кабинет третий день. Пробовал сбросить пароль через
    форму восстановления, но письмо не приходит ни на основную, ни на резервную
    почту. Очень срочно - нужно оплатить счет до конца недели!""",

    """Тикет #1002
    От: company@business.com
    Дата: 25.02.2024

    Добрый день. Мы крупный клиент вашей компании (контракт на 5 млн руб/год).
    Хотели бы обсудить возможность интеграции вашего API с нашей CRM системой.
    Также интересуют корпоративные скидки для увеличения объема услуг.""",

    """Тикет #1003
    От: user55@mail.ru
    Дата: 26.02.2024

    В мобильном приложении есть небольшая проблема: когда поворачиваешь экран в
    горизонтальное положение на странице статистики, часть графиков обрезается.
    Не критично, но немного неудобно.""",

    """Тикет #1004
    От: angry_customer@gmail.com
    Дата: 26.02.2024

    ЭТО ВОЗМУТИТЕЛЬНО!!! Вы списали деньги с моей карты за подписку, которую я
    отменил ЕЩЕ ДВА МЕСЯЦА НАЗАД! Требую немедленного возврата средств и компенсации!
    Уже написал жалобу в Роспотребнадзор. Если не решите в течение 24 часов,
    обращаюсь в суд!""",

    """Тикет #1005
    От: developer@startup.com
    Дата: 27.02.2024

    Обнаружил критическую уязвимость в вашем API - возможна SQL инъекция через
    параметр user_id в endpoint /api/v2/users. Детали отправил на security@yourcompany.com.
    Рекомендую срочно пропатчить.""",

    """Тикет #1006
    От: newuser@domain.com
    Дата: 27.02.2024

    Здравствуйте! Только начал пользоваться вашим сервисом. Подскажите, пожалуйста,
    как настроить уведомления на email? В документации не нашел этот раздел."""
]
```

**Что нужно сделать:**

Классифицируйте каждый тикет по **трем параметрам**:

1. **Категория**:
   - Технические проблемы
   - Вопросы об оплате/возврате
   - Запрос информации
   - Бизнес-предложение
   - Жалоба
   - Вопрос безопасности

2. **Приоритет**:
   - Низкий (не срочно, косметические проблемы)
   - Средний (важно, но есть время)
   - Высокий (срочно, влияет на работу клиента)
   - Критический (немедленно, влияет на безопасность/бизнес/репутацию)

3. **Тон клиента**:
   - Спокойный
   - Обеспокоенный
   - Недовольный
   - Агрессивный

**Ожидаемый результат:**

```
=== КЛАССИФИКАЦИЯ ТИКЕТОВ ===

Тикет #1001:
- Категория: [категория]
- Приоритет: [приоритет]
- Тон: [тон]
- Рекомендуемое действие: [краткая рекомендация]

[аналогично для всех тикетов]

=== СВОДКА ===
Критических тикетов: X
Высокий приоритет: X
Требуют немедленного ответа: [список номеров]
```

**Шаблон кода:**

```python
# Создайте промпт с явным определением всех категорий
prompt = """Классифицируй следующие тикеты в службу поддержки по трем параметрам:

КАТЕГОРИИ:
- Технические проблемы
- Вопросы об оплате/возврате
- Запрос информации
- Бизнес-предложение
- Жалоба
- Вопрос безопасности

ПРИОРИТЕТ:
- Низкий: не срочно, косметические проблемы
- Средний: важно, но есть время
- Высокий: срочно, влияет на работу клиента
- Критический: немедленно, влияет на безопасность/бизнес/репутацию

ТОН КЛИЕНТА:
- Спокойный
- Обеспокоенный
- Недовольный
- Агрессивный

ТИКЕТЫ:
"""

# Добавьте все тикеты
for i, ticket in enumerate(support_tickets, 1):
    prompt += f"\n{ticket}\n"

prompt += """
Для каждого тикета укажи:
- Категорию
- Приоритет
- Тон
- Краткую рекомендацию по действию (1 предложение)

Затем создай сводку с количеством критических тикетов и списком номеров,
требующих немедленного ответа."""

print("=== КЛАССИФИКАЦИЯ ТИКЕТОВ ===")
print(get_response(prompt, temperature=0.0))
```

---

### Задача 3.2: Извлечение сущностей с few-shot learning

**Исходные данные:**

```python
booking_requests = [
    """Здравствуйте! Меня зовут Иван Петров, телефон +7-905-123-4567.
    Хочу забронировать конференц-зал "Альфа" на 15 марта с 10:00 до 16:00
    для проведения тренинга на 25 человек. Нужен проектор, флипчарт и
    кофе-брейк в 12:00. Email для подтверждения: i.petrov@company.ru""",

    """Добрый день! Мария Смирнова, +7-916-999-8888. Нужна переговорная
    комната на 20 февраля, время с 14:00 до 15:30. Участников будет 8 человек.
    Требуется телевизор с HDMI для презентации. Свяжитесь со мной по email
    m.smirnova@tech.com или в телеграм @msmirnova""",

    """Привет! Это Алексей Сидоров. Мой контакт: +7-903-555-7777. Хочу провести
    собеседования 28 февраля в вашем коворкинге. Понадобится небольшая комната
    на 4 человека с 9:00 до 18:00 (весь день). Желательно тихое место. Если есть
    вопросы - пишите на a.sidorov@startup.io"""
]
```

**Что нужно сделать:**

1. Используйте **few-shot learning** для создания промпта
2. Извлеките из каждого запроса:
   - Имя клиента
   - Контактный телефон
   - Email
   - Дополнительные контакты (если есть)
   - Дата бронирования
   - Время начала и окончания
   - Тип помещения (конференц-зал, переговорная, комната)
   - Количество участников
   - Дополнительные требования (оборудование, услуги)

3. Выведите результат в формате JSON для каждого запроса

**Ожидаемый результат:**

```
=== ЗАПРОС 1 ===
{
  "client_name": "Иван Петров",
  "phone": "+7-905-123-4567",
  "email": "i.petrov@company.ru",
  "additional_contacts": null,
  "booking_date": "15 марта",
  "time_start": "10:00",
  "time_end": "16:00",
  "room_type": "конференц-зал",
  "room_name": "Альфа",
  "participants_count": 25,
  "additional_requirements": ["проектор", "флипчарт", "кофе-брейк в 12:00"]
}

[аналогично для остальных запросов]
```

**Шаблон кода:**

```python
# Создайте 2 примера для few-shot learning
example_1 = """
Вход: "Добрый день, я Елена Волкова, +7-912-345-6789. Бронирую переговорную
на 10 марта с 15:00 до 17:00 на 6 человек. Email: e.volkova@biz.ru"

Выход:
{
  "client_name": "Елена Волкова",
  "phone": "+7-912-345-6789",
  "email": "e.volkova@biz.ru",
  "additional_contacts": null,
  "booking_date": "10 марта",
  "time_start": "15:00",
  "time_end": "17:00",
  "room_type": "переговорная",
  "room_name": null,
  "participants_count": 6,
  "additional_requirements": []
}
"""

example_2 = """
Вход: "Здравствуйте! Это Дмитрий Козлов. Мой номер: +7-926-777-4444,
почта d.kozlov@corp.com. Нужен зал "Бета" на 5 апреля с 9:00 до 13:00,
будет 15 человек. Нужны проектор и доска, плюс обед в 12:00."

Выход:
{
  "client_name": "Дмитрий Козлов",
  "phone": "+7-926-777-4444",
  "email": "d.kozlov@corp.com",
  "additional_contacts": null,
  "booking_date": "5 апреля",
  "time_start": "9:00",
  "time_end": "13:00",
  "room_type": "зал",
  "room_name": "Бета",
  "participants_count": 15,
  "additional_requirements": ["проектор", "доска", "обед в 12:00"]
}
"""

# Создайте промпт с примерами
prompt_template = f"""Извлеки структурированную информацию из запросов на бронирование.

{example_1}

{example_2}

"""

for i, request in enumerate(booking_requests, 1):
    prompt = prompt_template + f"\nВход: \"{request}\"\n\nВыход:"

    print(f"\n=== ЗАПРОС {i} ===")
    print(get_response(prompt, temperature=0.0))
```

---

## Часть 4: Генерация и объяснение кода (25 минут)

### Задача 4.1: Генерация кода для обработки данных

**Задача:**

Создайте Python-скрипт для анализа продаж интернет-магазина.

**Требования:**

1. **Функция `calculate_sales_metrics(sales_data)`**:
   - Принимает список словарей с информацией о продажах
   - Вычисляет: общую выручку, средний чек, топ-3 товара по выручке
   - Возвращает словарь с метриками

2. **Функция `generate_sales_report(metrics)`**:
   - Принимает словарь с метриками
   - Создает текстовый отчет в читаемом формате
   - Возвращает строку с отчетом

3. **Дополнительно**:
   - Валидация входных данных
   - Обработка ошибок (try-except)
   - Docstrings для всех функций
   - Пример использования в блоке `if __name__ == "__main__"`

**Примеры данных:**

```python
sales_data = [
    {"product": "Ноутбук ASUS", "quantity": 5, "price": 45000},
    {"product": "Мышь Logitech", "quantity": 15, "price": 1500},
    {"product": "Клавиатура Keychron", "quantity": 8, "price": 7000},
    {"product": "Монитор Samsung", "quantity": 3, "price": 25000},
    {"product": "Наушники Sony", "quantity": 12, "price": 8000},
]
```

**Ожидаемый результат:**

```python
=== ОТЧЕТ О ПРОДАЖАХ ===
Общая выручка: 454,500 руб.
Количество заказов: 43
Средний чек: 10,569.77 руб.

Топ-3 товара по выручке:
1. Ноутбук ASUS - 225,000 руб.
2. Наушники Sony - 96,000 руб.
3. Монитор Samsung - 75,000 руб.
```

**Шаблон кода:**

```python
problem_description = """
Создай Python-скрипт для анализа продаж интернет-магазина.

ТРЕБОВАНИЯ:

1. Функция calculate_sales_metrics(sales_data):
   - Принимает список словарей: [{"product": str, "quantity": int, "price": float}, ...]
   - Вычисляет:
     * общую выручку (сумма quantity * price для всех товаров)
     * общее количество заказов (сумма всех quantity)
     * средний чек (общая выручка / количество заказов)
     * топ-3 товара по выручке (список кортежей: (название товара, выручка))
   - Возвращает словарь с метриками

2. Функция generate_sales_report(metrics):
   - Принимает словарь с метриками из предыдущей функции
   - Создает текстовый отчет с форматированием
   - Возвращает строку с отчетом

3. Дополнительно:
   - Проверка корректности входных данных (валидация)
   - Обработка ошибок через try-except
   - Docstrings для всех функций
   - Пример использования в if __name__ == "__main__"

ПРИМЕР ВХОДНЫХ ДАННЫХ:
sales_data = [
    {"product": "Ноутбук ASUS", "quantity": 5, "price": 45000},
    {"product": "Мышь Logitech", "quantity": 15, "price": 1500},
    {"product": "Клавиатура Keychron", "quantity": 8, "price": 7000},
    {"product": "Монитор Samsung", "quantity": 3, "price": 25000},
    {"product": "Наушники Sony", "quantity": 12, "price": 8000},
]

ОЖИДАЕМЫЙ ВЫВОД:
=== ОТЧЕТ О ПРОДАЖАХ ===
Общая выручка: 454,500 руб.
Количество заказов: 43
Средний чек: 10,569.77 руб.

Топ-3 товара по выручке:
1. Ноутбук ASUS - 225,000 руб.
2. Наушники Sony - 96,000 руб.
3. Монитор Samsung - 75,000 руб.
"""

prompt = f"""Сгенерируй полный Python код для решения следующей задачи:

{problem_description}

ВАЖНО:
- Код должен быть готов к запуску без изменений
- Включи все необходимые функции
- Добавь подробные docstrings
- Используй type hints где возможно
- Код должен быть хорошо структурирован и читаем
"""

print("=== СГЕНЕРИРОВАННЫЙ КОД ===")
generated_code = get_response(prompt, temperature=0.3)
print(generated_code)

# Для проверки можно выполнить сгенерированный код:
# exec(generated_code)
```

---

### Задача 4.2: Объяснение и модификация кода

**Исходный код:**

```python
def process_orders(orders, min_amount=0):
    result = {}
    for order in orders:
        customer = order.get('customer')
        amount = order.get('amount', 0)
        if amount >= min_amount:
            if customer in result:
                result[customer] = result[customer] + amount
            else:
                result[customer] = amount
    return sorted(result.items(), key=lambda x: x[1], reverse=True)

orders_list = [
    {'customer': 'Alice', 'amount': 150},
    {'customer': 'Bob', 'amount': 200},
    {'customer': 'Alice', 'amount': 300},
    {'customer': 'Charlie', 'amount': 50},
    {'customer': 'Bob', 'amount': 100},
]

top_customers = process_orders(orders_list, min_amount=100)
print(top_customers)
```

**Что нужно сделать:**

1. **Шаг 1**: Получите подробное объяснение кода:
   - Что делает функция
   - Как работает каждая строка
   - Что делает lambda в sorted()
   - Пример работы на конкретных данных

2. **Шаг 2**: Модифицируйте код:
   - Добавьте docstring
   - Добавьте type hints
   - Добавьте валидацию входных данных
   - Добавьте обработку ошибок
   - Переименуйте переменные для лучшей читаемости

3. **Шаг 3**: Расширьте функциональность:
   - Добавьте параметр `top_n` для ограничения количества результатов
   - Добавьте возможность сортировки по количеству заказов (не только по сумме)
   - Верните результат в виде списка словарей вместо списка кортежей

**Ожидаемый результат:**

```
=== ШАГ 1: ОБЪЯСНЕНИЕ КОДА ===
[Подробное пошаговое объяснение]

=== ШАГ 2: МОДИФИЦИРОВАННЫЙ КОД ===
[Код с улучшениями]

=== ШАГ 3: РАСШИРЕННАЯ ВЕРСИЯ ===
[Код с дополнительной функциональностью]
```

**Шаблон кода:**

```python
original_code = """
def process_orders(orders, min_amount=0):
    result = {}
    for order in orders:
        customer = order.get('customer')
        amount = order.get('amount', 0)
        if amount >= min_amount:
            if customer in result:
                result[customer] = result[customer] + amount
            else:
                result[customer] = amount
    return sorted(result.items(), key=lambda x: x[1], reverse=True)
"""

# Шаг 1: Объяснение
prompt_explain = f"""Объясни следующий Python код максимально подробно:

```python
{original_code}
```

Объясни:
1. Общее назначение функции (1-2 предложения)
2. Что делает каждая строка кода
3. Что делает lambda в sorted() и зачем нужен reverse=True
4. Покажи пример работы на данных:
   orders = [
       {{'customer': 'Alice', 'amount': 150}},
       {{'customer': 'Bob', 'amount': 200}},
       {{'customer': 'Alice', 'amount': 300}}
   ]

Пример: покажи пошагово, как изменяется переменная result"""

print("=== ШАГ 1: ОБЪЯСНЕНИЕ КОДА ===")
print(get_response(prompt_explain, temperature=0.0))

# Шаг 2: Модификация
prompt_modify = f"""Модифицируй следующий код:

```python
{original_code}
```

Выполни следующие улучшения:
1. Добавь подробный docstring с описанием Args, Returns и Examples
2. Добавь type hints для всех параметров и возвращаемого значения
3. Добавь валидацию: проверь, что orders - это список, а min_amount - число
4. Добавь обработку ошибок через try-except
5. Переименуй переменную result в более описательное имя

Верни полный модифицированный код."""

print("\n=== ШАГ 2: МОДИФИЦИРОВАННЫЙ КОД ===")
print(get_response(prompt_modify, temperature=0.0))

# Шаг 3: Расширение функциональности
prompt_extend = """# Ваш код здесь
# Создайте промпт для расширения функциональности
"""

# print("\n=== ШАГ 3: РАСШИРЕННАЯ ВЕРСИЯ ===")
# print(get_response(prompt_extend, temperature=0.0))
```

---

## Часть 5: Комплексная бизнес-задача (Бонус, +25 минут)

### Задача 5: Автоматизация обработки отзывов и генерации ответов

**Сценарий:**

Вы работаете в компании, которая получает десятки отзывов о своих онлайн-курсах ежедневно. Нужно автоматизировать процесс обработки отзывов.

**Исходные данные:**

```python
course_reviews = [
    {
        "id": 1,
        "course": "Python для начинающих",
        "author": "Александр М.",
        "date": "2024-02-15",
        "text": "The course was absolutely amazing! The instructor explained complex topics "
                "like decorators and generators in a very simple way. However, I found "
                "the final project a bit too challenging and would have appreciated more "
                "guidance. Overall, highly recommend this course for intermediate learners.",
        "language": "en"
    },
    {
        "id": 2,
        "course": "Data Science Практикум",
        "author": "Мария К.",
        "date": "2024-02-18",
        "text": "Курс просто ужасный! Материалы устаревшие, видео записаны еще в 2020 году. "
                "Преподаватель монотонно читает слайды, никакой интерактивности. Задания "
                "не проверяются неделями. За такую цену ожидала намного большего. "
                "Требую возврата денег!",
        "language": "ru"
    },
    {
        "id": 3,
        "course": "Machine Learning Advanced",
        "author": "Дмитрий П.",
        "date": "2024-02-20",
        "text": "Отличный курс для тех, кто уже имеет базовые знания ML. Практические задания "
                "очень полезные, особенно понравился проект по созданию рекомендательной "
                "системы. Единственный минус - мало времени уделено нейронным сетям, "
                "хотелось бы больше углубиться в эту тему.",
        "language": "ru"
    }
]
```

**Что нужно сделать:**

Создайте **автоматизированный пайплайн** обработки отзывов, который для каждого отзыва:

1. **Переводит текст на русский** (если отзыв на другом языке)
2. **Анализирует настроение** (по шкале от 1 до 5, где 1 - очень негативно, 5 - очень позитивно)
3. **Классифицирует по категории**:
   - Восторженный отзыв
   - Положительный с замечаниями
   - Нейтральный
   - Негативный
   - Критический (требует немедленного реагирования)
4. **Извлекает ключевые моменты**:
   - Что понравилось (плюсы)
   - Что не понравилось (минусы)
   - Предложения по улучшению (если есть)
5. **Генерирует персонализированный ответ** от лица компании:
   - Учитывает тон отзыва
   - Адресует конкретные пункты из отзыва
   - Предлагает решение проблем (если есть)
   - Благодарит за обратную связь
6. **Рассчитывает общую стоимость** обработки всех отзывов

**Ожидаемый результат:**

```
=========================
ОБРАБОТКА ОТЗЫВА #1
=========================
Курс: Python для начинающих
Автор: Александр М.
Дата: 2024-02-15

--- ПЕРЕВОД НА РУССКИЙ ---
[Переведенный текст]

--- АНАЛИЗ НАСТРОЕНИЯ ---
Оценка: 4/5 (Положительный)
Категория: Положительный с замечаниями

--- КЛЮЧЕВЫЕ МОМЕНТЫ ---
Плюсы:
- [пункт 1]
- [пункт 2]

Минусы:
- [пункт 1]

Предложения:
- [пункт 1]

--- СГЕНЕРИРОВАННЫЙ ОТВЕТ ---
[Персонализированный ответ от компании]

=========================
[Аналогично для остальных отзывов]
=========================

=== ИТОГОВАЯ СТАТИСТИКА ===
Всего отзывов обработано: 3

Распределение по категориям:
- Восторженных: 0
- Положительных с замечаниями: 2
- Нейтральных: 0
- Негативных: 1
- Критических: 0

Средняя оценка: 3.7/5

Стоимость обработки:
- Входные токены: XXX
- Выходные токены: XXX
- Общая стоимость: $0.XXXXXX
```

**Шаблон кода:**

```python
# Функция для обработки одного отзыва
def process_review(review: dict) -> dict:
    """
    Обрабатывает один отзыв через несколько этапов:
    1. Перевод (если нужен)
    2. Анализ настроения
    3. Извлечение ключевых моментов
    4. Генерация ответа
    """
    result = {
        "review_id": review["id"],
        "course": review["course"],
        "author": review["author"],
        "date": review["date"],
        "original_text": review["text"],
        "language": review["language"]
    }

    # Этап 1: Перевод (если необходимо)
    if review["language"] != "ru":
        prompt_translate = f"""Переведи следующий отзыв на русский язык:

{review['text']}

Верни только перевод, без дополнительных комментариев."""

        result["translated_text"] = get_response(prompt_translate, temperature=0.3)
    else:
        result["translated_text"] = review["text"]

    # Этап 2: Анализ настроения и классификация
    prompt_sentiment = f"""Проанализируй следующий отзыв о курсе:

{result['translated_text']}

Выполни два анализа:
1. Оцени настроение по шкале от 1 до 5:
   1 - очень негативно
   2 - негативно
   3 - нейтрально
   4 - позитивно
   5 - очень позитивно

2. Определи категорию:
   - Восторженный отзыв
   - Положительный с замечаниями
   - Нейтральный
   - Негативный
   - Критический (требует немедленного реагирования)

Формат ответа:
Оценка: [число]/5
Категория: [категория]"""

    sentiment_response = get_response(prompt_sentiment, temperature=0.0)
    result["sentiment_analysis"] = sentiment_response

    # Этап 3: Извлечение ключевых моментов
    prompt_extract = """# Ваш код здесь
    # Создайте промпт для извлечения плюсов, минусов и предложений
    """

    # result["key_points"] = get_response(prompt_extract, temperature=0.0)

    # Этап 4: Генерация ответа
    prompt_response = """# Ваш код здесь
    # Создайте промпт для генерации персонализированного ответа
    """

    # result["generated_response"] = get_response(prompt_response, temperature=0.7)

    return result

# Обработка всех отзывов
print("НАЧИНАЕМ ОБРАБОТКУ ОТЗЫВОВ...\n")

processed_reviews = []
for review in course_reviews:
    print(f"{'='*50}")
    print(f"ОБРАБОТКА ОТЗЫВА #{review['id']}")
    print(f"{'='*50}")
    print(f"Курс: {review['course']}")
    print(f"Автор: {review['author']}")
    print(f"Дата: {review['date']}\n")

    result = process_review(review)
    processed_reviews.append(result)

    print(f"--- ПЕРЕВОД НА РУССКИЙ ---")
    print(result['translated_text'])
    print(f"\n--- АНАЛИЗ НАСТРОЕНИЯ ---")
    print(result['sentiment_analysis'])

    # Раскомментируйте после реализации
    # print(f"\n--- КЛЮЧЕВЫЕ МОМЕНТЫ ---")
    # print(result['key_points'])
    # print(f"\n--- СГЕНЕРИРОВАННЫЙ ОТВЕТ ---")
    # print(result['generated_response'])

    print("\n")

# Итоговая статистика (реализуйте самостоятельно)
print(f"\n{'='*50}")
print("ИТОГОВАЯ СТАТИСТИКА")
print(f"{'='*50}")
print(f"Всего отзывов обработано: {len(processed_reviews)}")
# Добавьте расчет стоимости и другую статистику
```

**Дополнительные требования:**

- Используйте `temperature=0.0` для анализа и классификации (точность важнее креативности)
- Используйте `temperature=0.7` для генерации ответов (баланс между точностью и естественностью)
- Оптимизируйте промпты для минимизации количества токенов
- Добавьте подсчет токенов и стоимости для каждого этапа

---

## Критерии оценки

| Часть | Баллы | Критерий |
|-------|-------|----------|
| Часть 1 | 20 | Резюмирование (базовое, фокусное, структурированное) + расширение для разных аудиторий |
| Часть 2 | 20 | Многоэтапная трансформация текста + адаптация для разных аудиторий |
| Часть 3 | 25 | Многоклассовая классификация тикетов + извлечение сущностей с few-shot learning |
| Часть 4 | 20 | Генерация кода с валидацией + объяснение и модификация существующего кода |
| Часть 5 | 15 | Комплексный пайплайн обработки отзывов с расчетом стоимости |
| **Всего** | **100** | |

## Рекомендации по выполнению

1. **Начните с базовой конфигурации**: Убедитесь, что функция `get_response()` работает корректно
2. **Выполняйте задания последовательно**: Каждая часть развивает навыки, необходимые для следующей
3. **Экспериментируйте с temperature**: Для аналитических задач используйте низкие значения (0.0-0.3), для креативных - высокие (0.7-1.0)
4. **Итеративно улучшайте промпты**: Если результат не устраивает, добавьте больше контекста или уточните формат вывода
5. **Используйте разделители**: Четко отделяйте инструкции от данных (используйте тройные кавычки, пустые строки)
6. **Проверяйте промпты на граничных случаях**: Пустой ввод, очень длинный текст, смешанные языки
7. **Документируйте выводы**: Записывайте, какие промпты работают лучше и почему
8. **Оптимизируйте стоимость**: Старайтесь получить качественный результат с минимальным количеством токенов

## Что вы освоите

После выполнения этого задания вы сможете:

- ✅ Применять резюмирование для извлечения ключевой информации из больших текстов
- ✅ Использовать расширение текста для генерации маркетингового контента
- ✅ Трансформировать тексты для разных аудиторий и целей
- ✅ Классифицировать тексты по множественным параметрам с высокой точностью
- ✅ Извлекать структурированную информацию из неструктурированного текста
- ✅ Генерировать production-ready код с документацией и обработкой ошибок
- ✅ Объяснять и модифицировать существующий код
- ✅ Строить комплексные пайплайны обработки данных с LLM
- ✅ Оптимизировать стоимость API-вызовов
- ✅ Выбирать правильные параметры (temperature, prompting strategy) для конкретных задач

---

## Полезные паттерны

### Паттерн 1: Универсальный генератор промптов

```python
def create_business_prompt(
    task_type: str,
    input_data: str,
    output_format: str = "текст",
    constraints: list = None,
    tone: str = "профессиональный",
    examples: str = None
) -> str:
    """
    Универсальный генератор промптов для бизнес-задач.

    Args:
        task_type: Тип задачи (резюмирование, перевод, классификация)
        input_data: Входные данные
        output_format: Формат вывода (текст, JSON, список)
        constraints: Список ограничений
        tone: Требуемый тон
        examples: Few-shot примеры (опционально)

    Returns:
        Сформированный промпт
    """
    prompt_parts = [
        f"Задача: {task_type}",
        f"Тон: {tone}",
        f"Формат вывода: {output_format}"
    ]

    if constraints:
        prompt_parts.append("\nОграничения:")
        prompt_parts.extend([f"- {c}" for c in constraints])

    if examples:
        prompt_parts.append(f"\nПримеры:\n{examples}")

    prompt_parts.append(f"\nВходные данные:\n{input_data}")

    return "\n".join(prompt_parts)
```

### Паттерн 2: Обработка с подсчетом стоимости

```python
def get_response_with_cost(prompt: str, temperature: float = 1.0) -> tuple:
    """
    Получает ответ от модели и рассчитывает стоимость запроса.

    Returns:
        tuple: (response_text, cost, input_tokens, output_tokens)
    """
    response = client.chat.completions.create(
        model=os.getenv("BASE_MODEL"),
        messages=[{'role': 'user', 'content': prompt}],
        temperature=temperature
    )

    # Цены (пример для GPT-4)
    input_price = 0.03 / 1000   # $0.03 за 1K токенов
    output_price = 0.06 / 1000  # $0.06 за 1K токенов

    input_tokens = response.usage.prompt_tokens
    output_tokens = response.usage.completion_tokens

    cost = (input_tokens * input_price) + (output_tokens * output_price)

    return (
        response.choices[0].message.content,
        cost,
        input_tokens,
        output_tokens
    )
```

### Паттерн 3: Пакетная обработка с progress tracking

```python
from typing import List, Dict, Callable

def batch_process(
    items: List[Dict],
    process_func: Callable,
    show_progress: bool = True
) -> List[Dict]:
    """
    Обрабатывает список элементов с отслеживанием прогресса.

    Args:
        items: Список элементов для обработки
        process_func: Функция обработки одного элемента
        show_progress: Показывать прогресс

    Returns:
        Список обработанных результатов
    """
    results = []
    total = len(items)

    for i, item in enumerate(items, 1):
        if show_progress:
            print(f"Обработка {i}/{total}...", end="\r")

        result = process_func(item)
        results.append(result)

    if show_progress:
        print(f"Обработка завершена: {total}/{total}")

    return results
```

---

**Удачи в выполнении задания! 🚀**

*Если возникнут вопросы, обратитесь к материалам:*
- *[[Prompt_Engineering/Prompt_Engineering_for_Business_Applications|Prompt Engineering для бизнес-приложений]]*
- *[[Prompt_Engineering/Prompt_Engineering_Best_Practices|Лучшие практики Prompt Engineering]]*
- *[[Prompt_Engineering/Advanced_Prompt_Engineering_Strategies|Продвинутые стратегии Prompt Engineering]]*
